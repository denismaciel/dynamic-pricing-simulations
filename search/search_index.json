{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dynamic Pricing: a simulation-based comparsion","title":"Dynamic Pricing: a simulation-based comparsion"},{"location":"#dynamic-pricing-a-simulation-based-comparsion","text":"","title":"Dynamic Pricing: a simulation-based comparsion"},{"location":"notebooks/demand/nb_reservation_price_demand/","text":"import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import pandas as pd from plotnine import * import matplotlib.pyplot as plt from dynpric.notebook import project_root_dir theme_set(theme_light()) FIGS_DIR = project_root_dir() / \"figs\" def simulate_wip (): \u03bb = 100 \u03b8 _lo = 0 . 6 \u03b8 _hi = 0 . 4 \u03b2 _lo = 10 \u03b2 _hi = 3 * \u03b2 _lo n = np . random . poisson ( \u03bb , size = 1 ) n_lo , n_hi = np . random . multinomial ( n , ( \u03b8 _lo , \u03b8 _hi )) wips = pd . concat ( [ pd . DataFrame ( { \"wip\" : np . random . exponential ( \u03b2 _lo , n_lo ), \"group\" : \"low\" } ), pd . DataFrame ( { \"wip\" : np . random . exponential ( \u03b2 _hi , n_hi ), \"group\" : \"high\" } ), ] ) return wips wips = [ simulate_wip () for _ in range ( 50 )] def demand_fn ( wip , prices ): \"\"\"Calculates the demand for every price point in `prices` \"\"\" # Demand q for price p q = lambda wip , p : ( wip [ \"wip\" ] > p ). sum () pq_pairs = [( p , q ( wip , p )) for p in prices ] return pd . DataFrame ( pq_pairs , columns = [ \"p\" , \"q\" ]) curves = [ demand_fn ( wip , range ( 0 , 100 , 2 )) for wip in wips ] demand_curve = ggplot () for curve in curves : demand_curve += geom_line ( curve , aes ( \"p\" , \"q\" ), alpha = 0 . 1 ) demand_curve = ( demand_curve + labs ( y = 'Quantity q' , x = 'Price p' ) + theme ( text = element_text ( size = 8 )) ) demand_curve . save ( FIGS_DIR / 'wip_demand.png' , dpi = 300 , height = 3 , width = 3 ) demand_curve all_wips = pd . concat ( wips ) pt99 = np . percentile ( all_wips [ 'wip' ], 99 ) wip_distribution = ( ggplot ( pd . concat ( wips ), aes ( x = \"wip\" , fill = \"group\" )) + geom_histogram ( position = \"identity\" , bins = 80 , alpha = 0 . 5 ) + labs ( y = 'Count' , x = 'Willigness to Pay' , fill = \"\" ) + xlim (( 0 , pt99 )) + theme ( text = element_text ( size = 8 ), legend_position = \"none\" ) ) wip_distribution . save ( FIGS_DIR / 'wip_distribution.png' , dpi = 300 , height = 3 , width = 3 ) wip_distribution","title":"Demand functions"},{"location":"notebooks/dynamic_programming/nb_dynamic_programming/","text":"Dynamic pricing as a dynamic programming problem Intro We present the basics of dynamic programming and frame the dynamic pricing as a dynamic programming problem. In its simplest form, dynamic programming problems consist of two principal features: a discrete-time dynamic process and a cost function that is additive over time. There is a process that happens in stages and an agent is allowed to act in each stage with the objective of minimizing a pre-defined cost function. Every action of the agent must not be considered in isolation. Rather, while deciding what to do in period \\(k\\) , the agent should usually weigh in the effects that her current actions might have on subsequent (future) stages. Such a general framework, as one might expect, has applications in very diverse fields such as computer science, operations research and economics. A dynamic system is usually described as follows: \\[\\begin{equation} x_{k+1} = f_k(x_k, u_k, w_k) \\end{equation}\\] where \\(k \\in \\{0,1...,N-1\\}\\) is the time index \\(x_k\\) is the state of the system at time \\(k\\) \\(u_k\\) is the control variable through which the agent can influence the system's state \\(w_k\\) is the disturbance, a random variable whose realization also determines the system's state \\(f_k\\) is a function that that describes the mechanism through which the system state is updated. To fully characterize the decision problem, a cost function that will steer the agent's decision-making. The total cost is \\[\\begin{equation} g_N(x_N) + \\sum\\limits_{k=0}^{N-1} g_k(x_k, u_k, w_k) \\end{equation}\\] where \\(g_N(x_N)\\) is the final cost occured right at the very end of the process. Pricing as a dynamic programming problem The state \\(x_k\\) is the inventory. The control \\(u_k\\) is the price. \\(u_k \\in \\{5, 10\\}\\) The random noise \\(w_k\\) is the demand. \\[\\begin{equation} x_{k+1} = f(x_k, u_k, w_k) = \\begin{cases} x_k - 1 & \\text{if $w_k = 1$ }\\\\ x_k & \\text{if $w_k = 0$ }\\\\ \\end{cases} \\end{equation}\\] Cost function $g_k = $ import random import numpy as np stock = 10 # Initial stock def pick_strategy (): if random . random () > 0.5 : return 5 return 10 def demand ( p ): mapping = { 5 : 0.7 , 10 : 0.3 , np . inf : 0 } try : prob = mapping [ p ] except KeyError : raise ValueError ( f \"Price { p } not allowed\" ) if random . random () > prob : return 0 return 1 for _ in range ( 40 ): if stock > 0 : p = pick_strategy () elif stock == 0 : p = np . inf else : raise ValueError ( \"Stock cannot be negative\" ) q = demand ( p ) stock -= q profit = p * q print ( p , q , profit , stock ) 10 0 0 10 10 0 0 10 10 0 0 10 5 1 5 9 10 0 0 9 5 1 5 8 5 0 0 8 10 1 10 7 10 0 0 7 5 0 0 7 10 1 10 6 10 0 0 6 10 0 0 6 5 1 5 5 10 0 0 5 5 1 5 4 5 1 5 3 10 0 0 3 10 1 10 2 10 0 0 2 5 1 5 1 5 1 5 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 demand ( np . inf ) 1","title":"Dynamic programming"},{"location":"notebooks/dynamic_programming/nb_dynamic_programming/#dynamic-pricing-as-a-dynamic-programming-problem","text":"","title":"Dynamic pricing as a dynamic programming problem"},{"location":"notebooks/dynamic_programming/nb_dynamic_programming/#intro","text":"We present the basics of dynamic programming and frame the dynamic pricing as a dynamic programming problem. In its simplest form, dynamic programming problems consist of two principal features: a discrete-time dynamic process and a cost function that is additive over time. There is a process that happens in stages and an agent is allowed to act in each stage with the objective of minimizing a pre-defined cost function. Every action of the agent must not be considered in isolation. Rather, while deciding what to do in period \\(k\\) , the agent should usually weigh in the effects that her current actions might have on subsequent (future) stages. Such a general framework, as one might expect, has applications in very diverse fields such as computer science, operations research and economics. A dynamic system is usually described as follows: \\[\\begin{equation} x_{k+1} = f_k(x_k, u_k, w_k) \\end{equation}\\] where \\(k \\in \\{0,1...,N-1\\}\\) is the time index \\(x_k\\) is the state of the system at time \\(k\\) \\(u_k\\) is the control variable through which the agent can influence the system's state \\(w_k\\) is the disturbance, a random variable whose realization also determines the system's state \\(f_k\\) is a function that that describes the mechanism through which the system state is updated. To fully characterize the decision problem, a cost function that will steer the agent's decision-making. The total cost is \\[\\begin{equation} g_N(x_N) + \\sum\\limits_{k=0}^{N-1} g_k(x_k, u_k, w_k) \\end{equation}\\] where \\(g_N(x_N)\\) is the final cost occured right at the very end of the process.","title":"Intro"},{"location":"notebooks/dynamic_programming/nb_dynamic_programming/#pricing-as-a-dynamic-programming-problem","text":"The state \\(x_k\\) is the inventory. The control \\(u_k\\) is the price. \\(u_k \\in \\{5, 10\\}\\) The random noise \\(w_k\\) is the demand. \\[\\begin{equation} x_{k+1} = f(x_k, u_k, w_k) = \\begin{cases} x_k - 1 & \\text{if $w_k = 1$ }\\\\ x_k & \\text{if $w_k = 0$ }\\\\ \\end{cases} \\end{equation}\\]","title":"Pricing as a dynamic programming problem"},{"location":"notebooks/dynamic_programming/nb_dynamic_programming/#cost-function","text":"$g_k = $ import random import numpy as np stock = 10 # Initial stock def pick_strategy (): if random . random () > 0.5 : return 5 return 10 def demand ( p ): mapping = { 5 : 0.7 , 10 : 0.3 , np . inf : 0 } try : prob = mapping [ p ] except KeyError : raise ValueError ( f \"Price { p } not allowed\" ) if random . random () > prob : return 0 return 1 for _ in range ( 40 ): if stock > 0 : p = pick_strategy () elif stock == 0 : p = np . inf else : raise ValueError ( \"Stock cannot be negative\" ) q = demand ( p ) stock -= q profit = p * q print ( p , q , profit , stock ) 10 0 0 10 10 0 0 10 10 0 0 10 5 1 5 9 10 0 0 9 5 1 5 8 5 0 0 8 10 1 10 7 10 0 0 7 5 0 0 7 10 1 10 6 10 0 0 6 10 0 0 6 5 1 5 5 10 0 0 5 5 1 5 4 5 1 5 3 10 0 0 3 10 1 10 2 10 0 0 2 5 1 5 1 5 1 5 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 demand ( np . inf ) 1","title":"Cost function"},{"location":"notebooks/online_network_revenue_management/analysis/","text":"import warnings from plotnine import * import pandas as pd from dynpric.notebook import project_root_dir warnings . filterwarnings ( \"ignore\" ) N_TRIALS = 500 N_PERIODS = 500 FIGS_DIR = project_root_dir () / \"figs\" # Read in simulation data ts_fixed = pd . read_parquet ( f \"data/ts_fixed_trials { N_TRIALS } _periods { N_PERIODS } .parquet\" ) clairvoyant = pd . read_parquet ( f \"data/clairvoyant_trials { N_TRIALS } _periods { N_PERIODS } .parquet\" ) ts_fixed . period_revenue . mean (), clairvoyant_avg_revenue (9.6599992, 10.1027144) revenue = ts_fixed . groupby ( \"t\" ) . period_revenue . mean () clairvoyant_avg_revenue = clairvoyant . period_revenue . mean () revenue_over_time = ( ggplot ( aes ( revenue . index , revenue )) + geom_line () + lims ( y = ( 0 , 15 )) + geom_hline ( aes ( yintercept = clairvoyant_avg_revenue ), color = \"red\" ) + labs ( y = \"Revenue\" , x = \"Periods\" ) ) revenue_over_time . save ( FIGS_DIR / \"online_net_reveue_over_time.png\" , dpi = 300 , height = 3 , width = 3 ) revenue_over_time <ggplot: (309929633)> df = ( ts_fixed [[ \"t\" , \"price_29.9\" , \"price_34.9\" , \"price_39.9\" , \"price_44.9\" ]] . groupby ( \"t\" ) . mean () . reset_index () . melt ( id_vars = \"t\" , var_name = \"price\" , value_name = \"pp\" ) ) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } t price pp 0 0 price_29.9 0.500667 1 1 price_29.9 0.500667 2 2 price_29.9 0.502333 3 3 price_29.9 0.502333 4 4 price_29.9 0.502000 ... ... ... ... 1995 495 price_44.9 0.099265 1996 496 price_44.9 0.099279 1997 497 price_44.9 0.099321 1998 498 price_44.9 0.099291 1999 499 price_44.9 0.099360 2000 rows \u00d7 3 columns ( ggplot ( df , aes ( x = \"t\" , y = \"pp\" , color = \"price\" )) + geom_line () + labs ( y = \"Probability\" ) + lims ( y = ( 0 , 1 )) + facet_wrap ( \"price\" ) ) <ggplot: (299132953)> counts_per_step = ts_fixed . groupby ([ \"t\" , \"price\" ]) . size () . reset_index ( name = \"n\" ) counts_per_step [ \"pp\" ] = counts_per_step [ \"n\" ] / N_TRIALS plot = ( ggplot ( counts_per_step , aes ( \"t\" , \"pp\" , color = \"factor(price)\" )) + geom_line () + labs ( title = \"How often price x was offered in period t averaged across all trials\" , y = \"%\" , color = \"Price Levels\" , ) + lims ( y = ( 0 , 1 )) + facet_wrap ( \"price\" ) ) plot <ggplot: (302878349)> counts_per_step . groupby ([ \"price\" ]) . pp . mean () price 29.9 0.004829 34.9 0.026703 39.9 0.635172 44.9 0.336088 Name: pp, dtype: float64 pd . DataFrame ( { \"clairvoyant\" : clairvoyant . groupby ( \"t\" ) . period_revenue . mean (), \"ts_fixed\" : ts_fixed . groupby ( \"t\" ) . period_revenue . mean (), } ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } clairvoyant ts_fixed t 0 10.6438 5.0184 1 9.8256 5.1978 2 11.1224 5.8358 3 9.3668 5.7960 4 9.9254 6.1450 ... ... ... 495 11.3220 9.7558 496 10.0152 9.9354 497 9.8456 9.9854 498 9.5464 9.4166 499 9.4168 10.9430 500 rows \u00d7 2 columns","title":"Analysis"},{"location":"notebooks/online_network_revenue_management/sim/","text":"import random from typing import List , NamedTuple , Tuple , Iterable , Dict , Any import numpy as np from scipy.optimize import linprog from scipy.optimize.optimize import OptimizeResult from dynpric.market import Market , Price , Quantity from dynpric.seller import Seller from dynpric.priors import BetaPrior from dynpric.simulation_engine import simulate , trial_factory First, we define the containers of information. PriceLevel is responsible for storing the true probability ( PriceLevel.true_prob ) of one unit being sold under a specific price ( PriceLevel.price ). Belief is the analogous of PriceLevel but under the view of the seller. Instead of the true probability for a given price, it stores the prior the distribution the seller associates with that price. Notice that all elements of an instance of PriceLevel are immutable, since we don't allow for the probability of one unit being sold to change over time. However, Belief.prior is mutable, since we're updating it at the end of every period as the seller acquires new information about the demand function. Due to its mutability, we wrap the Belief s in the constructor function beliefs , so that every trial can start from a clean slate: specifically, the seller starts with a uniform prior for the probability of a unit being sold for every price level. class PriceLevel ( NamedTuple ): \"\"\" Container of the information that characterizes the state of a price level \"\"\" price : Price true_prob : float PriceLevels = Iterable [ PriceLevel ] price_levels : PriceLevels = ( PriceLevel ( 29.9 , 0.8 ), PriceLevel ( 34.9 , 0.6 ), PriceLevel ( 39.9 , 0.3 ), PriceLevel ( 44.9 , 0.1 ), ) class Belief ( NamedTuple ): price : Price prior : BetaPrior Beliefs = List [ Belief ] def beliefs () -> Beliefs : \"\"\" Reset the state of beliefs when initializing a new simulation trial \"\"\" return [ Belief ( 29.9 , BetaPrior ( 1 , 1 )), Belief ( 34.9 , BetaPrior ( 1 , 1 )), Belief ( 39.9 , BetaPrior ( 1 , 1 )), Belief ( 44.9 , BetaPrior ( 1 , 1 )), ] # def compute_expected_value( # price_strategy: Iterable[float], # prices: Iterable[float], # true_prob: Iterable[float], # ) -> float: # \"\"\" # price_strategy: # probability distribution over allowed set of prices # price: # vector of allowed prices # true_prob: # true probabilty of customer buying given a price # \"\"\" # return np.dot(price_strategy, np.array(true_prob) * np.array(prices)) How does the seller behave? In order to choose the prices , the seller: Esimates demand Chooses optimal price mixture Samples on price from the mixture After the demand is realized, the seller: Updates her belief about the demand Updates her inventory The first action of the seller is to estimate the demand. def find_optimal_price ( self , prices , demand ) -> OptimizeResult : assert len ( prices ) == len ( demand ) # The reason for the minus sign is that scipy only does minimizations objective = [ - ( p * d ) for p , d in zip ( prices , demand )] # --- Constraints --- # 1. Demand is smaller equal than available inventory c1 = [ demand , self . c ] # Sum of probabilities smaller equal zero c2 = [( 1 , 1 , 1 , 1 ,), 1 ] # 3. Probability of picking a price must be greater than zero c3 = [( - 1 , - 1 , - 1 , - 1 ,), 0 ] constraints = [ c1 , c2 , c3 ] lhs_ineq = [] rhs_ineq = [] for lhs , rhs in constraints : lhs_ineq . append ( lhs ) rhs_ineq . append ( rhs ) opt = linprog ( c = objective , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) return opt class _ : c = 0.25 demand = [ pl . true_prob for pl in price_levels ] price = [ pl . price for pl in price_levels ] find_optimal_price ( _ , price , demand ) con: array([], dtype=float64) fun: -10.1 message: 'Optimization terminated successfully.' nit: 3 slack: array([-5.55111512e-17, 0.00000000e+00, 1.00000000e+00]) status: 0 success: True x: array([0. , 0. , 0.75, 0.25]) class ConstrainedSeller ( Seller ): _find_optimal_price = find_optimal_price def __init__ ( self , beliefs , strategy , inventory , n_periods ): self . beliefs = beliefs self . strategy = strategy self . inventory = inventory self . c = inventory / n_periods def choose_price ( self ): demand = self . _estimate_demand () prices = [ belief . price for belief in self . beliefs ] opt_result = self . _find_optimal_price ( prices , demand ) def sample_price ( probs , prices ) -> float : assert len ( probs ) == len ( prices ) rounded_probs = np . round ( probs , decimals = 3 ) if any ( p < 0 for p in rounded_probs ): raise ValueError ( rounded_probs ) normalized_probs = [ p / sum ( rounded_probs ) for p in rounded_probs ] sampled_price = np . random . choice ( prices , size = 1 , p = normalized_probs ) return float ( sampled_price ) chosen_price = sample_price ( opt_result . x , prices ) return chosen_price def observe_demand ( self , q : Quantity , p : Price ) -> None : # update beliefs with observerd demand belief = next ( belief for belief in self . beliefs if belief . price == p ) belief . prior . update ( q ) def _estimate_demand ( self ) -> List [ int ]: demand = [ self . strategy ( belief ) for belief in self . beliefs ] return demand class BinomialMarket ( Market ): def __init__ ( self , price_levels : PriceLevels ) -> None : self . price_levels = price_levels def _simulate_buying_decision ( self , price_level : PriceLevel ) -> Quantity : if random . random () > price_level . true_prob : return 0 return 1 def realize_demand ( self , p : Price ) -> Quantity : for pl in self . price_levels : if pl . price == p : return self . _simulate_buying_decision ( pl ) else : raise ValueError ( f \"Price { p } is not an allowed price.\" ) def greedy ( b : Belief ) -> float : return b . prior . expected_value # type: ignore def thompson ( b : Belief ) -> float : return b . prior . sample () # type: ignore Simulation Parameters N_TRIALS = 500 N_PERIODS = 250 alpha = 0.25 INVENTORY = alpha * N_PERIODS TS-fixed def initialize_trial () -> Tuple [ Market , Seller ]: return ( BinomialMarket ( price_levels ), ConstrainedSeller ( beliefs (), thompson , INVENTORY , N_PERIODS ,), ) def record_state ( t : int , market : Market , seller : Seller , p : Price , q : Quantity ) -> Dict [ str , Any ]: beliefs = { f \"price_ { b . price } \" : b . prior . expected_value for b in seller . beliefs } return { \"t\" : t , \"price\" : p , \"period_revenue\" : p * q , ** beliefs } simulation = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( initialize_trial , record_state ), ) Starting simulation... Finished trial number 0 Finished trial number 100 Finished trial number 50 Finished trial number 200 Finished trial number 150 Finished trial number 250 Finished trial number 300 Finished trial number 350 Finished trial number 450 Finished trial number 400 Simulation completed in 88.788211888 seconds def sample_optimal_price ( _ ): probs = [ 0 , 0 , 0.75 , 0.25 ] prices = [ 29.9 , 34.9 , 39.9 , 44.9 ] return float ( np . random . choice ( prices , size = 1 , p = probs )) ConstrainedSeller . choose_price = sample_optimal_price 0.75 * 39.9 * 0.3 + 0.25 * 44.9 * 0.1 import time start = time . perf_counter () simulation = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( initialize_trial , record_state ) ) end = time . perf_counter () print ( \"Simulation completed in {} \" . format ( end - start )) from plotnine import * from dynpric.simulation_engine import flatten_results results = flatten_results ( simulation ) from collections import Counter Counter ( results . price ) revenue = results . groupby ( 't' ) . period_revenue . mean () ( ggplot ( aes ( revenue . index , revenue )) + geom_line () + lims ( y = ( 5 , 20 )) + geom_hline ( aes ( yintercept = 10 ), color = 'red' ) ) results [[ 't' , 'price_29.9' , 'price_34.9' , 'price_39.9' , 'price_44.9' ]] . groupby ( 't' ) . mean () . plot () counts_per_step = results . groupby ([ \"t\" , \"price\" ]) . size () . reset_index ( name = \"n\" ) counts_per_step [ \"pp\" ] = counts_per_step [ \"n\" ] / N_TRIALS plot = ( ggplot ( counts_per_step , aes ( \"t\" , \"pp\" , color = \"factor(price)\" )) + geom_line () + labs ( title = \"How often price x was offered in period t averaged across all trials\" , y = '%' , color = \"Price Levels\" ) + lims ( y = ( 0 , 1 )) + facet_wrap ( 'price' ) ) plot boo = counts_per_step [ \"price\" ] == 44.9 ( ggplot ( counts_per_step [ boo ], aes ( \"t\" , \"pp\" )) + geom_line () + labs ( y = \"Demos\" , color = \"A\" ) ) counts_per_step . groupby ([ \"price\" ]) . pp . mean ()","title":"Sim"},{"location":"notebooks/online_network_revenue_management/sim/#how-does-the-seller-behave","text":"In order to choose the prices , the seller: Esimates demand Chooses optimal price mixture Samples on price from the mixture After the demand is realized, the seller: Updates her belief about the demand Updates her inventory The first action of the seller is to estimate the demand. def find_optimal_price ( self , prices , demand ) -> OptimizeResult : assert len ( prices ) == len ( demand ) # The reason for the minus sign is that scipy only does minimizations objective = [ - ( p * d ) for p , d in zip ( prices , demand )] # --- Constraints --- # 1. Demand is smaller equal than available inventory c1 = [ demand , self . c ] # Sum of probabilities smaller equal zero c2 = [( 1 , 1 , 1 , 1 ,), 1 ] # 3. Probability of picking a price must be greater than zero c3 = [( - 1 , - 1 , - 1 , - 1 ,), 0 ] constraints = [ c1 , c2 , c3 ] lhs_ineq = [] rhs_ineq = [] for lhs , rhs in constraints : lhs_ineq . append ( lhs ) rhs_ineq . append ( rhs ) opt = linprog ( c = objective , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) return opt class _ : c = 0.25 demand = [ pl . true_prob for pl in price_levels ] price = [ pl . price for pl in price_levels ] find_optimal_price ( _ , price , demand ) con: array([], dtype=float64) fun: -10.1 message: 'Optimization terminated successfully.' nit: 3 slack: array([-5.55111512e-17, 0.00000000e+00, 1.00000000e+00]) status: 0 success: True x: array([0. , 0. , 0.75, 0.25]) class ConstrainedSeller ( Seller ): _find_optimal_price = find_optimal_price def __init__ ( self , beliefs , strategy , inventory , n_periods ): self . beliefs = beliefs self . strategy = strategy self . inventory = inventory self . c = inventory / n_periods def choose_price ( self ): demand = self . _estimate_demand () prices = [ belief . price for belief in self . beliefs ] opt_result = self . _find_optimal_price ( prices , demand ) def sample_price ( probs , prices ) -> float : assert len ( probs ) == len ( prices ) rounded_probs = np . round ( probs , decimals = 3 ) if any ( p < 0 for p in rounded_probs ): raise ValueError ( rounded_probs ) normalized_probs = [ p / sum ( rounded_probs ) for p in rounded_probs ] sampled_price = np . random . choice ( prices , size = 1 , p = normalized_probs ) return float ( sampled_price ) chosen_price = sample_price ( opt_result . x , prices ) return chosen_price def observe_demand ( self , q : Quantity , p : Price ) -> None : # update beliefs with observerd demand belief = next ( belief for belief in self . beliefs if belief . price == p ) belief . prior . update ( q ) def _estimate_demand ( self ) -> List [ int ]: demand = [ self . strategy ( belief ) for belief in self . beliefs ] return demand class BinomialMarket ( Market ): def __init__ ( self , price_levels : PriceLevels ) -> None : self . price_levels = price_levels def _simulate_buying_decision ( self , price_level : PriceLevel ) -> Quantity : if random . random () > price_level . true_prob : return 0 return 1 def realize_demand ( self , p : Price ) -> Quantity : for pl in self . price_levels : if pl . price == p : return self . _simulate_buying_decision ( pl ) else : raise ValueError ( f \"Price { p } is not an allowed price.\" ) def greedy ( b : Belief ) -> float : return b . prior . expected_value # type: ignore def thompson ( b : Belief ) -> float : return b . prior . sample () # type: ignore","title":"How does the seller behave?"},{"location":"notebooks/online_network_revenue_management/sim/#simulation-parameters","text":"N_TRIALS = 500 N_PERIODS = 250 alpha = 0.25 INVENTORY = alpha * N_PERIODS","title":"Simulation Parameters"},{"location":"notebooks/online_network_revenue_management/sim/#ts-fixed","text":"def initialize_trial () -> Tuple [ Market , Seller ]: return ( BinomialMarket ( price_levels ), ConstrainedSeller ( beliefs (), thompson , INVENTORY , N_PERIODS ,), ) def record_state ( t : int , market : Market , seller : Seller , p : Price , q : Quantity ) -> Dict [ str , Any ]: beliefs = { f \"price_ { b . price } \" : b . prior . expected_value for b in seller . beliefs } return { \"t\" : t , \"price\" : p , \"period_revenue\" : p * q , ** beliefs } simulation = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( initialize_trial , record_state ), ) Starting simulation... Finished trial number 0 Finished trial number 100 Finished trial number 50 Finished trial number 200 Finished trial number 150 Finished trial number 250 Finished trial number 300 Finished trial number 350 Finished trial number 450 Finished trial number 400 Simulation completed in 88.788211888 seconds def sample_optimal_price ( _ ): probs = [ 0 , 0 , 0.75 , 0.25 ] prices = [ 29.9 , 34.9 , 39.9 , 44.9 ] return float ( np . random . choice ( prices , size = 1 , p = probs )) ConstrainedSeller . choose_price = sample_optimal_price 0.75 * 39.9 * 0.3 + 0.25 * 44.9 * 0.1 import time start = time . perf_counter () simulation = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( initialize_trial , record_state ) ) end = time . perf_counter () print ( \"Simulation completed in {} \" . format ( end - start )) from plotnine import * from dynpric.simulation_engine import flatten_results results = flatten_results ( simulation ) from collections import Counter Counter ( results . price ) revenue = results . groupby ( 't' ) . period_revenue . mean () ( ggplot ( aes ( revenue . index , revenue )) + geom_line () + lims ( y = ( 5 , 20 )) + geom_hline ( aes ( yintercept = 10 ), color = 'red' ) ) results [[ 't' , 'price_29.9' , 'price_34.9' , 'price_39.9' , 'price_44.9' ]] . groupby ( 't' ) . mean () . plot () counts_per_step = results . groupby ([ \"t\" , \"price\" ]) . size () . reset_index ( name = \"n\" ) counts_per_step [ \"pp\" ] = counts_per_step [ \"n\" ] / N_TRIALS plot = ( ggplot ( counts_per_step , aes ( \"t\" , \"pp\" , color = \"factor(price)\" )) + geom_line () + labs ( title = \"How often price x was offered in period t averaged across all trials\" , y = '%' , color = \"Price Levels\" ) + lims ( y = ( 0 , 1 )) + facet_wrap ( 'price' ) ) plot boo = counts_per_step [ \"price\" ] == 44.9 ( ggplot ( counts_per_step [ boo ], aes ( \"t\" , \"pp\" )) + geom_line () + labs ( y = \"Demos\" , color = \"A\" ) ) counts_per_step . groupby ([ \"price\" ]) . pp . mean ()","title":"TS-fixed"},{"location":"notebooks/online_network_revenue_management/simulation/","text":"Online Network Revenue Management Below is the implementation of the TS-Fixed algorithm described in Ferreira, Kris Johnson, David Simchi-Levi, and He Wang. \u201cOnline Network Revenue Management Using Thompson Sampling\u201d Setup The setup consists of a seller of one good with limited stock and that can set one of four different prices during a selling season that lasts T periods. The available prices are 29.9, 34.9, 39.9, 44.9. Each price is associated with a demand that is entirely unknown to the seller at the beginning of the season. At each period, the demand can be either 0 or 1 unit. The seller can directly affect the probability that demand turns out to be one by setting the price. The correspondence between price and demand is the following: When the price is 29.9, demand will be 1 with probability 0.8 When the price is 34.9, demand will be 1 with probability 0.6 When the price is 39.9, demand will be 1 with probability 0.3 When the price is 44.9, demand will be 1 with probability 0.1 As one would expect, the higher the price, the lower the expected value of the demand. As already mentioned, this correspondence is unknown to the seller at period t = 0. The way the seller learns about the demand is by setting different prices and observing the resulting demand. In what follows, we consider the seller to be Bayesian. The seller has the prior belief that the probability for every price is \\(Beta(1,1)\\) distributed. It is equivalent to a uniform distribution over the interval \\([0,1]\\) . For every available price, the seller assumes that the corresponding probability is equally likely any number between 0 and 1. Thus, the seller beliefs do not incorporate even the commonsense that the higher the price, the lower the demand. According to seller's priors, it is as likely that the price 29.9 corresponds to a probability of 0.01 as the price 44.9 corresponds to a probability of 0.99. We will see later that, despite this rather unreasonable priors, the seller ends up learning the true demand parameters quite accurately. Now to the code. We start with the necessary imports. import random import copy from typing import List , NamedTuple , Tuple , Iterable , Dict , Any import numpy as np from scipy.optimize import linprog from scipy.optimize.optimize import OptimizeResult from dynpric.market import Market , Price , Quantity from dynpric.seller import Seller from dynpric.priors import BetaPrior from dynpric.simulation_engine import simulate , trial_factory Next, we need to decide how to store the necessary information during the simulations. The prices and the true demand probabilities do not change during the simulation. For that reason, we store them in a named tuple called PriceLevel . PriceLevel.true_prob gives the probability that demand equals one when price is set to PriceLevel.price . The beliefs of the seller needs to be updated at the end of every period when the seller learns about a new realization of the demand. With that in mind, we store the beliefs in the named tuple Belief . It contains two elements: a price, which is a float , and an instance of BetaPrior . The method BetaPrior.update is responsible for the Bayesian updating. It takes the realization of the demand and updates the parameters \\(\\alpha\\) and \\(\\beta\\) of the Beta distribution. Also, at the beginning of every trial, the beliefs need to be reset to the priors \\(Beta(1,1)\\) . This is accomplished with the function beliefs . class PriceLevel ( NamedTuple ): \"\"\" Container of the information that characterizes the state of a price level \"\"\" price : Price true_prob : float PriceLevels = Iterable [ PriceLevel ] price_levels : PriceLevels = ( PriceLevel ( 29.9 , 0.8 ), PriceLevel ( 34.9 , 0.6 ), PriceLevel ( 39.9 , 0.3 ), PriceLevel ( 44.9 , 0.1 ), ) class Belief ( NamedTuple ): price : Price prior : BetaPrior Beliefs = List [ Belief ] def beliefs () -> Beliefs : \"\"\" Reset the state of beliefs when initializing a new simulation trial \"\"\" return [ Belief ( 29.9 , BetaPrior ( 1 , 1 )), Belief ( 34.9 , BetaPrior ( 1 , 1 )), Belief ( 39.9 , BetaPrior ( 1 , 1 )), Belief ( 44.9 , BetaPrior ( 1 , 1 )), ] Seller's optimization problem The process for the seller to determine which price set comprises three steps: Esimate the demand Given the demand estimates, comupte an optimal price mixture Sample one price from the mixture Demand estimation . The first step is to pick a demand probability for each price in order to feed it to the optimization algorithm. This is done via Thompson sampling: the demand probability is sampled from the beta distribution associated with each price. The method Belief.BetaPrior.sample implements exactly that. An alternative to come up with the demand probability is to select the expected value of the beta distribution instead of sampling. This is the greedy approach and is exemplified by the function greedy . def thompson ( b : Belief ) -> float : return b . prior . sample () # type: ignore def greedy ( b : Belief ) -> float : return b . prior . expected_value # type: ignore Optimization . Given the pairs of prices and demand probabilities, the seller now needs to solve an optimization problem. Ideally, she wants to maximize revenue, but she also must manage a limited inventory. The model specifies that the seller starts with a fixed amount of inventory and is not allowed to replenish it during the sales season. TS-fixed deals with the inventory constraint in a rather static way. During the optimization, we enforce that the resulting expected demand is smaller or equal to a constant \\(c\\) , which is the ratio between the inventory and the length of the selling season. \\(c\\) is set at the beginning of the selling season and is not updated to reflect the actual development of the inventory. That is the reason why it bears \"fixed\" in its name. The optimization result is a vector \\(x = (x_1, x_2, x_3, x_4)\\) , the elements of which tell us the probability with which a price level should be chosen. We formalize the optimization problem below mathematically and in code. For solving it, we use the library scipy. Notice that scipy only does minimizations requires all of the constraints to be specified in the form of \"less or equal to.\" That is the reason for the somewhat unintuitive minus signs used in the objective function and constraints. \\[\\begin{equation} LP(d(t)): \\max_{x_1, x_2, x_3, x_4} Q = (p_1 q_1) x_1 + (p_2 q_2) x_2 + (p_3 q_3) x_3 + (p_4 q_4) x_4 \\\\ \\text{subject to } \\\\ Q < c \\\\ x_1 + x_2 + x_3 + x_4 \\leq 1 \\\\ x_1, x_2, x_3, x_4 \\geq 0 \\end{equation}\\] def find_optimal_price ( self , prices , demand ) -> OptimizeResult : assert len ( prices ) == len ( demand ) # The reason for the minus sign is that scipy only does minimizations objective = [ - ( p * d ) for p , d in zip ( prices , demand )] # --- Constraints --- # 1. Demand is smaller equal than available inventory c1 = [ demand , self . c ] # Sum of probabilities smaller equal one c2 = [( 1 , 1 , 1 , 1 ,), 1 ] # 3. Probability of picking a price must be or equal to greater than zero c3 = [ [( - 1 , 0 , 0 , 0 ,), 0 ], [( 0 , - 1 , 0 , 0 ,), 0 ], [( 0 , 0 , - 1 , 0 ,), 0 ], [( 0 , 0 , 0 , - 1 ,), 0 ], ] constraints = [ c1 , c2 , * c3 ] lhs_ineq = [] rhs_ineq = [] for lhs , rhs in constraints : lhs_ineq . append ( lhs ) rhs_ineq . append ( rhs ) opt = linprog ( c = objective , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) return opt The solution to the optimization problem of a clairvoyant seller (a seller that knows the actual underlying demand probabilities from the start) is shown below. We create the ThrowAwayClass because find_optimal_price is meant to be a method and takes an instance (usually denoted by self in Python) as its first argument. To compute the optimal prices, we need the attribute c representing the ratio between the inventory and the periods in the selling season. If we set the inventory to 1/4 of the selling season length, the optimal price is to choose \\$ 44.9 with probability 0.25 and \\$ 39.9 with probability 0.75. If we set it to 1/2, the optimal price is to choose \\ \\(39.9 1/3 of the time and \\\\\\) 34.9 the other 2/3. This illustrates the general tendency that ceteris paribues if selling season becomes longer, the optimal price increase if the initial stock gets larger, the optimal price decreases class ThrowAwayClass0 : c = 0.25 class ThrowAwayClass1 : c = 0.5 demand = [ pl . true_prob for pl in price_levels ] # true probabilities price = [ pl . price for pl in price_levels ] opt_result = find_optimal_price ( ThrowAwayClass0 , price , demand ) print ( \"=== Low inventory to duration of selling season ratio ===\" ) for p , prob in zip ( price , opt_result . x ): print ( f \"Choose price { p } with probability { round ( prob , 2 ) } \" ) opt_result = find_optimal_price ( ThrowAwayClass1 , price , demand ) print ( \" \\n\\n === High inventory to duration of selling season ratio ===\" ) for p , prob in zip ( price , opt_result . x ): print ( f \"Choose price { p } with probability { round ( prob , 2 ) } \" ) === Low inventory to duration of selling season ratio === Choose price 29 . 9 with probability 0 . 0 Choose price 34 . 9 with probability 0 . 0 Choose price 39 . 9 with probability 0 . 75 Choose price 44 . 9 with probability 0 . 25 === High inventory to duration of selling season ratio === Choose price 29 . 9 with probability 0 . 0 Choose price 34 . 9 with probability 0 . 67 Choose price 39 . 9 with probability 0 . 33 Choose price 44 . 9 with probability 0 . 0 Putting everything together We now have all the elements to construct the TSFixedSeller class. To initialize an instance of the class, we need to specify: the beliefs about the demand function, which are beta distributed a strategy to estimate the demand given the current beliefs, which is done via Thompson sampling the initial inventory and the length of the season With this information, the seller is now ready to interact with the environment. At every period, the interaction takes place via two actions: setting a price ( TSFixedSeller.choose_price ) and observing the realized demand ( TSFixedSeller.observe_demand ). The price-setting is the result ofestimating the demand via Thompson sampling ( TSFixedSeller._estimate_demand ), passing the estimated demans through the optimizer ( TSFixedSeller._find_optimal_price ) and finally sampling one price out of the distribution given by the optimizer. The price is then fed into the BernoulliMarket , which simulates the demand by runnning a Bernoulli trial with success probability dependent on the price set. Finally, the seller observes the realized demand (either 0 or 1) and updates her beliefs about the selected price in a Bayesian fashion. class TSFixedSeller ( Seller ): _find_optimal_price = find_optimal_price def __init__ ( self , beliefs , strategy , inventory , n_periods ) -> None : self . beliefs = beliefs self . strategy = strategy self . inventory = inventory self . c = inventory / n_periods def choose_price ( self ) -> Price : demand = self . _estimate_demand () prices = [ belief . price for belief in self . beliefs ] opt_result = self . _find_optimal_price ( prices , demand ) def sample_price ( probs , prices ) -> float : assert len ( probs ) == len ( prices ) # Ensure probs are always positive rounded_probs = np . round ( probs , decimals = 3 ) if any ( p < 0 for p in rounded_probs ): raise ValueError ( rounded_probs ) # Normalize probs to add up to one normalized_probs = [ p / sum ( rounded_probs ) for p in rounded_probs ] sampled_price = np . random . choice ( prices , size = 1 , p = normalized_probs ) return float ( sampled_price ) chosen_price = sample_price ( opt_result . x , prices ) return chosen_price def observe_demand ( self , q : Quantity , p : Price ) -> None : # update beliefs with observerd demand belief = next ( belief for belief in self . beliefs if belief . price == p ) belief . prior . update ( q ) def _estimate_demand ( self ) -> List [ int ]: demand = [ self . strategy ( belief ) for belief in self . beliefs ] return demand class BernoulliMarket ( Market ): def __init__ ( self , price_levels : PriceLevels ) -> None : self . price_levels = price_levels def _simulate_buying_decision ( self , price_level : PriceLevel ) -> Quantity : if random . random () > price_level . true_prob : return 0 return 1 def realize_demand ( self , p : Price ) -> Quantity : for pl in self . price_levels : if pl . price == p : return self . _simulate_buying_decision ( pl ) else : raise ValueError ( f \"Price { p } is not an allowed price.\" ) Simulation Parameters We run 500 trials, each of which consisting of selling season with 500 periods. Inventory is set to 1/4 of the selling season length. At the end of each period, we record the price, revenue and the belief about the underlying demand of the selller for later analysis. N_TRIALS = 500 N_PERIODS = 500 alpha = 0.25 INVENTORY = alpha * N_PERIODS TS-fixed Run the simulation for TSFixerSeller . Note that the trials might finish out of order. It happens because they are running in multiple processes in order to take advantage of all the CPU cores of the computer. def initialize_trial () -> Tuple [ Market , Seller ]: return ( BernoulliMarket ( price_levels ), TSFixedSeller ( beliefs (), thompson , INVENTORY , N_PERIODS ,), ) def record_state ( t : int , market : Market , seller : Seller , p : Price , q : Quantity ) -> Dict [ str , Any ]: beliefs = { f \"price_ { b . price } \" : b . prior . expected_value for b in seller . beliefs } return { \"t\" : t , \"price\" : p , \"period_revenue\" : p * q , ** beliefs } ts_fixed = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( initialize_trial , record_state ), ) from dynpric.simulation_engine import flatten_results flatten_results ( ts_fixed ) . to_parquet ( f \"data/ts_fixed_trials { N_TRIALS } _periods { N_PERIODS } .parquet\" ) Starting simulation... Finished trial number 0 Finished trial number 100 Finished trial number 50 Finished trial number 200 Finished trial number 150 Finished trial number 250 Finished trial number 300 Finished trial number 350 Finished trial number 450 Finished trial number 400 Simulation completed in 204.427882092 seconds Clairvoyant Seller We simulate the same setting for a clairvoyant seller. In fact, we can even reuse all of TSFixedSeller functionality only change the choose_price method by enforcing it to always return the optimal price mixture. def sample_optimal_price ( _ ): probs = [ 0 , 0 , 0.75 , 0.25 ] prices = [ 29.9 , 34.9 , 39.9 , 44.9 ] return float ( np . random . choice ( prices , size = 1 , p = probs )) ClairvoyantSeller = copy . deepcopy ( TSFixedSeller ) ClairvoyantSeller . choose_price = sample_optimal_price def clairvoyant_initialize_trial () -> Tuple [ Market , Seller ]: return ( BernoulliMarket ( price_levels ), ClairvoyantSeller ( beliefs (), thompson , INVENTORY , N_PERIODS ,), ) clairvoyant = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( clairvoyant_initialize_trial , record_state ), ) flatten_results ( clairvoyant ) . to_parquet ( f \"data/clairvoyant_trials { N_TRIALS } _periods { N_PERIODS } .parquet\" ) Starting simulation... Finished trial number 0 Finished trial number 100 Finished trial number 50 Finished trial number 200 Finished trial number 150 Finished trial number 250 Finished trial number 300 Finished trial number 350 Finished trial number 450 Finished trial number 400 Simulation completed in 6.081968265 seconds","title":"Simulation"},{"location":"notebooks/online_network_revenue_management/simulation/#online-network-revenue-management","text":"Below is the implementation of the TS-Fixed algorithm described in Ferreira, Kris Johnson, David Simchi-Levi, and He Wang. \u201cOnline Network Revenue Management Using Thompson Sampling\u201d","title":"Online Network Revenue Management"},{"location":"notebooks/online_network_revenue_management/simulation/#setup","text":"The setup consists of a seller of one good with limited stock and that can set one of four different prices during a selling season that lasts T periods. The available prices are 29.9, 34.9, 39.9, 44.9. Each price is associated with a demand that is entirely unknown to the seller at the beginning of the season. At each period, the demand can be either 0 or 1 unit. The seller can directly affect the probability that demand turns out to be one by setting the price. The correspondence between price and demand is the following: When the price is 29.9, demand will be 1 with probability 0.8 When the price is 34.9, demand will be 1 with probability 0.6 When the price is 39.9, demand will be 1 with probability 0.3 When the price is 44.9, demand will be 1 with probability 0.1 As one would expect, the higher the price, the lower the expected value of the demand. As already mentioned, this correspondence is unknown to the seller at period t = 0. The way the seller learns about the demand is by setting different prices and observing the resulting demand. In what follows, we consider the seller to be Bayesian. The seller has the prior belief that the probability for every price is \\(Beta(1,1)\\) distributed. It is equivalent to a uniform distribution over the interval \\([0,1]\\) . For every available price, the seller assumes that the corresponding probability is equally likely any number between 0 and 1. Thus, the seller beliefs do not incorporate even the commonsense that the higher the price, the lower the demand. According to seller's priors, it is as likely that the price 29.9 corresponds to a probability of 0.01 as the price 44.9 corresponds to a probability of 0.99. We will see later that, despite this rather unreasonable priors, the seller ends up learning the true demand parameters quite accurately. Now to the code. We start with the necessary imports. import random import copy from typing import List , NamedTuple , Tuple , Iterable , Dict , Any import numpy as np from scipy.optimize import linprog from scipy.optimize.optimize import OptimizeResult from dynpric.market import Market , Price , Quantity from dynpric.seller import Seller from dynpric.priors import BetaPrior from dynpric.simulation_engine import simulate , trial_factory Next, we need to decide how to store the necessary information during the simulations. The prices and the true demand probabilities do not change during the simulation. For that reason, we store them in a named tuple called PriceLevel . PriceLevel.true_prob gives the probability that demand equals one when price is set to PriceLevel.price . The beliefs of the seller needs to be updated at the end of every period when the seller learns about a new realization of the demand. With that in mind, we store the beliefs in the named tuple Belief . It contains two elements: a price, which is a float , and an instance of BetaPrior . The method BetaPrior.update is responsible for the Bayesian updating. It takes the realization of the demand and updates the parameters \\(\\alpha\\) and \\(\\beta\\) of the Beta distribution. Also, at the beginning of every trial, the beliefs need to be reset to the priors \\(Beta(1,1)\\) . This is accomplished with the function beliefs . class PriceLevel ( NamedTuple ): \"\"\" Container of the information that characterizes the state of a price level \"\"\" price : Price true_prob : float PriceLevels = Iterable [ PriceLevel ] price_levels : PriceLevels = ( PriceLevel ( 29.9 , 0.8 ), PriceLevel ( 34.9 , 0.6 ), PriceLevel ( 39.9 , 0.3 ), PriceLevel ( 44.9 , 0.1 ), ) class Belief ( NamedTuple ): price : Price prior : BetaPrior Beliefs = List [ Belief ] def beliefs () -> Beliefs : \"\"\" Reset the state of beliefs when initializing a new simulation trial \"\"\" return [ Belief ( 29.9 , BetaPrior ( 1 , 1 )), Belief ( 34.9 , BetaPrior ( 1 , 1 )), Belief ( 39.9 , BetaPrior ( 1 , 1 )), Belief ( 44.9 , BetaPrior ( 1 , 1 )), ]","title":"Setup"},{"location":"notebooks/online_network_revenue_management/simulation/#sellers-optimization-problem","text":"The process for the seller to determine which price set comprises three steps: Esimate the demand Given the demand estimates, comupte an optimal price mixture Sample one price from the mixture Demand estimation . The first step is to pick a demand probability for each price in order to feed it to the optimization algorithm. This is done via Thompson sampling: the demand probability is sampled from the beta distribution associated with each price. The method Belief.BetaPrior.sample implements exactly that. An alternative to come up with the demand probability is to select the expected value of the beta distribution instead of sampling. This is the greedy approach and is exemplified by the function greedy . def thompson ( b : Belief ) -> float : return b . prior . sample () # type: ignore def greedy ( b : Belief ) -> float : return b . prior . expected_value # type: ignore Optimization . Given the pairs of prices and demand probabilities, the seller now needs to solve an optimization problem. Ideally, she wants to maximize revenue, but she also must manage a limited inventory. The model specifies that the seller starts with a fixed amount of inventory and is not allowed to replenish it during the sales season. TS-fixed deals with the inventory constraint in a rather static way. During the optimization, we enforce that the resulting expected demand is smaller or equal to a constant \\(c\\) , which is the ratio between the inventory and the length of the selling season. \\(c\\) is set at the beginning of the selling season and is not updated to reflect the actual development of the inventory. That is the reason why it bears \"fixed\" in its name. The optimization result is a vector \\(x = (x_1, x_2, x_3, x_4)\\) , the elements of which tell us the probability with which a price level should be chosen. We formalize the optimization problem below mathematically and in code. For solving it, we use the library scipy. Notice that scipy only does minimizations requires all of the constraints to be specified in the form of \"less or equal to.\" That is the reason for the somewhat unintuitive minus signs used in the objective function and constraints. \\[\\begin{equation} LP(d(t)): \\max_{x_1, x_2, x_3, x_4} Q = (p_1 q_1) x_1 + (p_2 q_2) x_2 + (p_3 q_3) x_3 + (p_4 q_4) x_4 \\\\ \\text{subject to } \\\\ Q < c \\\\ x_1 + x_2 + x_3 + x_4 \\leq 1 \\\\ x_1, x_2, x_3, x_4 \\geq 0 \\end{equation}\\] def find_optimal_price ( self , prices , demand ) -> OptimizeResult : assert len ( prices ) == len ( demand ) # The reason for the minus sign is that scipy only does minimizations objective = [ - ( p * d ) for p , d in zip ( prices , demand )] # --- Constraints --- # 1. Demand is smaller equal than available inventory c1 = [ demand , self . c ] # Sum of probabilities smaller equal one c2 = [( 1 , 1 , 1 , 1 ,), 1 ] # 3. Probability of picking a price must be or equal to greater than zero c3 = [ [( - 1 , 0 , 0 , 0 ,), 0 ], [( 0 , - 1 , 0 , 0 ,), 0 ], [( 0 , 0 , - 1 , 0 ,), 0 ], [( 0 , 0 , 0 , - 1 ,), 0 ], ] constraints = [ c1 , c2 , * c3 ] lhs_ineq = [] rhs_ineq = [] for lhs , rhs in constraints : lhs_ineq . append ( lhs ) rhs_ineq . append ( rhs ) opt = linprog ( c = objective , A_ub = lhs_ineq , b_ub = rhs_ineq , method = \"revised simplex\" ) return opt The solution to the optimization problem of a clairvoyant seller (a seller that knows the actual underlying demand probabilities from the start) is shown below. We create the ThrowAwayClass because find_optimal_price is meant to be a method and takes an instance (usually denoted by self in Python) as its first argument. To compute the optimal prices, we need the attribute c representing the ratio between the inventory and the periods in the selling season. If we set the inventory to 1/4 of the selling season length, the optimal price is to choose \\$ 44.9 with probability 0.25 and \\$ 39.9 with probability 0.75. If we set it to 1/2, the optimal price is to choose \\ \\(39.9 1/3 of the time and \\\\\\) 34.9 the other 2/3. This illustrates the general tendency that ceteris paribues if selling season becomes longer, the optimal price increase if the initial stock gets larger, the optimal price decreases class ThrowAwayClass0 : c = 0.25 class ThrowAwayClass1 : c = 0.5 demand = [ pl . true_prob for pl in price_levels ] # true probabilities price = [ pl . price for pl in price_levels ] opt_result = find_optimal_price ( ThrowAwayClass0 , price , demand ) print ( \"=== Low inventory to duration of selling season ratio ===\" ) for p , prob in zip ( price , opt_result . x ): print ( f \"Choose price { p } with probability { round ( prob , 2 ) } \" ) opt_result = find_optimal_price ( ThrowAwayClass1 , price , demand ) print ( \" \\n\\n === High inventory to duration of selling season ratio ===\" ) for p , prob in zip ( price , opt_result . x ): print ( f \"Choose price { p } with probability { round ( prob , 2 ) } \" ) === Low inventory to duration of selling season ratio === Choose price 29 . 9 with probability 0 . 0 Choose price 34 . 9 with probability 0 . 0 Choose price 39 . 9 with probability 0 . 75 Choose price 44 . 9 with probability 0 . 25 === High inventory to duration of selling season ratio === Choose price 29 . 9 with probability 0 . 0 Choose price 34 . 9 with probability 0 . 67 Choose price 39 . 9 with probability 0 . 33 Choose price 44 . 9 with probability 0 . 0","title":"Seller's optimization problem"},{"location":"notebooks/online_network_revenue_management/simulation/#putting-everything-together","text":"We now have all the elements to construct the TSFixedSeller class. To initialize an instance of the class, we need to specify: the beliefs about the demand function, which are beta distributed a strategy to estimate the demand given the current beliefs, which is done via Thompson sampling the initial inventory and the length of the season With this information, the seller is now ready to interact with the environment. At every period, the interaction takes place via two actions: setting a price ( TSFixedSeller.choose_price ) and observing the realized demand ( TSFixedSeller.observe_demand ). The price-setting is the result ofestimating the demand via Thompson sampling ( TSFixedSeller._estimate_demand ), passing the estimated demans through the optimizer ( TSFixedSeller._find_optimal_price ) and finally sampling one price out of the distribution given by the optimizer. The price is then fed into the BernoulliMarket , which simulates the demand by runnning a Bernoulli trial with success probability dependent on the price set. Finally, the seller observes the realized demand (either 0 or 1) and updates her beliefs about the selected price in a Bayesian fashion. class TSFixedSeller ( Seller ): _find_optimal_price = find_optimal_price def __init__ ( self , beliefs , strategy , inventory , n_periods ) -> None : self . beliefs = beliefs self . strategy = strategy self . inventory = inventory self . c = inventory / n_periods def choose_price ( self ) -> Price : demand = self . _estimate_demand () prices = [ belief . price for belief in self . beliefs ] opt_result = self . _find_optimal_price ( prices , demand ) def sample_price ( probs , prices ) -> float : assert len ( probs ) == len ( prices ) # Ensure probs are always positive rounded_probs = np . round ( probs , decimals = 3 ) if any ( p < 0 for p in rounded_probs ): raise ValueError ( rounded_probs ) # Normalize probs to add up to one normalized_probs = [ p / sum ( rounded_probs ) for p in rounded_probs ] sampled_price = np . random . choice ( prices , size = 1 , p = normalized_probs ) return float ( sampled_price ) chosen_price = sample_price ( opt_result . x , prices ) return chosen_price def observe_demand ( self , q : Quantity , p : Price ) -> None : # update beliefs with observerd demand belief = next ( belief for belief in self . beliefs if belief . price == p ) belief . prior . update ( q ) def _estimate_demand ( self ) -> List [ int ]: demand = [ self . strategy ( belief ) for belief in self . beliefs ] return demand class BernoulliMarket ( Market ): def __init__ ( self , price_levels : PriceLevels ) -> None : self . price_levels = price_levels def _simulate_buying_decision ( self , price_level : PriceLevel ) -> Quantity : if random . random () > price_level . true_prob : return 0 return 1 def realize_demand ( self , p : Price ) -> Quantity : for pl in self . price_levels : if pl . price == p : return self . _simulate_buying_decision ( pl ) else : raise ValueError ( f \"Price { p } is not an allowed price.\" )","title":"Putting everything together"},{"location":"notebooks/online_network_revenue_management/simulation/#simulation","text":"","title":"Simulation"},{"location":"notebooks/online_network_revenue_management/simulation/#parameters","text":"We run 500 trials, each of which consisting of selling season with 500 periods. Inventory is set to 1/4 of the selling season length. At the end of each period, we record the price, revenue and the belief about the underlying demand of the selller for later analysis. N_TRIALS = 500 N_PERIODS = 500 alpha = 0.25 INVENTORY = alpha * N_PERIODS","title":"Parameters"},{"location":"notebooks/online_network_revenue_management/simulation/#ts-fixed","text":"Run the simulation for TSFixerSeller . Note that the trials might finish out of order. It happens because they are running in multiple processes in order to take advantage of all the CPU cores of the computer. def initialize_trial () -> Tuple [ Market , Seller ]: return ( BernoulliMarket ( price_levels ), TSFixedSeller ( beliefs (), thompson , INVENTORY , N_PERIODS ,), ) def record_state ( t : int , market : Market , seller : Seller , p : Price , q : Quantity ) -> Dict [ str , Any ]: beliefs = { f \"price_ { b . price } \" : b . prior . expected_value for b in seller . beliefs } return { \"t\" : t , \"price\" : p , \"period_revenue\" : p * q , ** beliefs } ts_fixed = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( initialize_trial , record_state ), ) from dynpric.simulation_engine import flatten_results flatten_results ( ts_fixed ) . to_parquet ( f \"data/ts_fixed_trials { N_TRIALS } _periods { N_PERIODS } .parquet\" ) Starting simulation... Finished trial number 0 Finished trial number 100 Finished trial number 50 Finished trial number 200 Finished trial number 150 Finished trial number 250 Finished trial number 300 Finished trial number 350 Finished trial number 450 Finished trial number 400 Simulation completed in 204.427882092 seconds","title":"TS-fixed"},{"location":"notebooks/online_network_revenue_management/simulation/#clairvoyant-seller","text":"We simulate the same setting for a clairvoyant seller. In fact, we can even reuse all of TSFixedSeller functionality only change the choose_price method by enforcing it to always return the optimal price mixture. def sample_optimal_price ( _ ): probs = [ 0 , 0 , 0.75 , 0.25 ] prices = [ 29.9 , 34.9 , 39.9 , 44.9 ] return float ( np . random . choice ( prices , size = 1 , p = probs )) ClairvoyantSeller = copy . deepcopy ( TSFixedSeller ) ClairvoyantSeller . choose_price = sample_optimal_price def clairvoyant_initialize_trial () -> Tuple [ Market , Seller ]: return ( BernoulliMarket ( price_levels ), ClairvoyantSeller ( beliefs (), thompson , INVENTORY , N_PERIODS ,), ) clairvoyant = simulate ( S = N_TRIALS , T = N_PERIODS , trial_runner = trial_factory ( clairvoyant_initialize_trial , record_state ), ) flatten_results ( clairvoyant ) . to_parquet ( f \"data/clairvoyant_trials { N_TRIALS } _periods { N_PERIODS } .parquet\" ) Starting simulation... Finished trial number 0 Finished trial number 100 Finished trial number 50 Finished trial number 200 Finished trial number 150 Finished trial number 250 Finished trial number 300 Finished trial number 350 Finished trial number 450 Finished trial number 400 Simulation completed in 6.081968265 seconds","title":"Clairvoyant Seller"},{"location":"notebooks/thompson_sampling/nb_thompson_vs_greedy/","text":"import random from typing import NamedTuple , List , Callable , Dict , Any , Tuple import time import pandas as pd from dynpric.seller import Seller from dynpric.market import Market , Price , Quantity from dynpric.priors import BetaPrior from dynpric.simulation_engine import simulate , trial_factory class PriceLevel ( NamedTuple ): \"\"\" Container of the information that characterizes the state of a price level \"\"\" price : Price true_prob : float PriceLevels = List [ PriceLevel ] class Belief ( NamedTuple ): price : Price prior : BetaPrior Beliefs = List [ Belief ] price_levels = [ PriceLevel ( 29.9 , 0.6 ), PriceLevel ( 34.9 , 0.4 ), PriceLevel ( 39.9 , 0.25 ), ] def beliefs () -> Beliefs : \"\"\" Reset the state of beliefs when initializing a new simulation trial \"\"\" return [ Belief ( 29.9 , BetaPrior ( 1 , 1 )), Belief ( 34.9 , BetaPrior ( 1 , 1 )), Belief ( 39.9 , BetaPrior ( 1 , 1 )), ] def greedy ( b : Belief ) -> float : return b . prior . expected_value # type: ignore def thompson ( b : Belief ) -> float : return b . prior . sample () # type: ignore class BinomialSeller ( Seller ): def __init__ ( self , beliefs : Beliefs , strategy : Callable [[ Belief ], float ]) -> None : self . beliefs = beliefs self . strategy = strategy def choose_price ( self ) -> Price : profit = [ belief . price * self . strategy ( belief ) for belief in self . beliefs ] idx = profit . index ( max ( profit )) return self . beliefs [ idx ] . price def observe_demand ( self , q : Quantity , p : Price ) -> None : # update beliefs with observerd demand belief = next ( belief for belief in self . beliefs if belief . price == p ) belief . prior . update ( q ) class BinomialMarket ( Market ): def __init__ ( self , price_levels : PriceLevels ) -> None : self . price_levels = price_levels def _simulate_buying_decision ( self , price_level : PriceLevel ) -> Quantity : if random . random () > price_level . true_prob : return 0 return 1 def realize_demand ( self , p : Price ) -> Quantity : for pl in self . price_levels : if pl . price == p : return self . _simulate_buying_decision ( pl ) else : raise ValueError ( f \"Price { p } is not an allowed price.\" ) def initialize_trial () -> Tuple [ Market , Seller ]: return ( BinomialMarket ( price_levels ), BinomialSeller ( beliefs (), strategy = greedy ), ) def record_state ( t : int , market : Market , seller : Seller , p : Price , q : Quantity ) -> Dict [ str , Any ]: return { \"t\" : t , \"price\" : p } start = time . perf_counter () simulation = simulate ( S = 10000 , T = 1000 , trial_runner = trial_factory ( initialize_trial , record_state ), execution_mode = 'sequential' ) end = time . perf_counter () print ( f \"It took { end - start } \" ) Starting simulation... Finished trial number 0 Finished trial number 1000 Finished trial number 2000 Finished trial number 3000 Finished trial number 4000 Finished trial number 5000 Finished trial number 6000 Finished trial number 7000 Finished trial number 8000 Finished trial number 9000 It took 43.300607673 def flatten_results ( simulation : List [ Dict ]) -> pd . DataFrame : \"\"\" Creates a dataframe out of the results of a simulation. The expected structure of the simulation object: [ { \"s\": 0, \"periods\": [ {'t': 0, 'price': 29.99}, {'t': 1, 'price': 34.99}, ... ] }, ... ] \"\"\" flat = [] for trial in simulation : for period in trial [ \"periods\" ]: flat . append ({ \"s\" : trial [ \"s\" ], ** period }) return pd . DataFrame ( flat ) results = flatten_results ( simulation ) counts_per_step = results . groupby ([ \"t\" , \"price\" ]) . size () . reset_index ( name = \"n\" ) counts_per_step [ \"pp\" ] = counts_per_step [ \"n\" ] / max ( counts_per_step [ \"t\" ] + 1 ) from plotnine import ggplot , aes , geom_line , labs plot = ( ggplot ( counts_per_step , aes ( \"t\" , \"pp\" , color = \"factor(price)\" )) + geom_line () + labs ( y = \"Demos\" , color = \"A\" ) ) plot <ggplot: (285468880)>","title":"Thompson sampling"}]}