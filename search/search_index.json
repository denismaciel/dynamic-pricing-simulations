{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dynamic Pricing: a simulation-based comparsion","title":"Dynamic Pricing: a simulation-based comparsion"},{"location":"#dynamic-pricing-a-simulation-based-comparsion","text":"","title":"Dynamic Pricing: a simulation-based comparsion"},{"location":"notebooks/simulations/nb_dynamic_programming/","text":"Dynamic pricing as a dynamic programming problem Intro We present the basics of dynamic programming and frame the dynamic pricing as a dynamic programming problem. In its simplest form, dynamic programming problems consist of two principal features: a discrete-time dynamic process and a cost function that is additive over time. There is a process that happens in stages and an agent is allowed to act in each stage with the objective of minimizing a pre-defined cost function. Every action of the agent must not be considered in isolation. Rather, while deciding what to do in period $k$, the agent should usually weigh in the effects that her current actions might have on subsequent (future) stages. Such a general framework, as one might expect, has applications in very diverse fields such as computer science, operations research and economics. A dynamic system is usually described as follows: \\begin{equation} x_{k+1} = f_k(x_k, u_k, w_k) \\end{equation} where $k \\in {0,1...,N-1}$ is the time index $x_k$ is the state of the system at time $k$ $u_k$ is the control variable through which the agent can influence the system's state $w_k$ is the disturbance, a random variable whose realization also determines the system's state $f_k$ is a function that that describes the mechanism through which the system state is updated. To fully characterize the decision problem, a cost function that will steer the agent's decision-making. The total cost is \\begin{equation} g_N(x_N) + \\sum\\limits_{k=0}^{N-1} g_k(x_k, u_k, w_k) \\end{equation} where $g_N(x_N)$ is the final cost occured right at the very end of the process. Pricing as a dynamic programming problem The state $x_k$ is the inventory. The control $u_k$ is the price. $u_k \\in {5, 10}$ The random noise $w_k$ is the demand. \\begin{equation} x_{k+1} = f(x_k, u_k, w_k) = \\begin{cases} x_k - 1 & \\text{if $w_k = 1$ }\\ x_k & \\text{if $w_k = 0$ }\\ \\end{cases} \\end{equation} Cost function $g_k = $ import random import numpy as np stock = 10 # Initial stock def pick_strategy (): if random . random () > 0.5 : return 5 return 10 def demand ( p ): mapping = { 5 : 0.7 , 10 : 0.3 , np . inf : 0 } try : prob = mapping [ p ] except KeyError : raise ValueError ( f \"Price { p } not allowed\" ) if random . random () > prob : return 0 return 1 for _ in range ( 40 ): if stock > 0 : p = pick_strategy () elif stock == 0 : p = np . inf else : raise ValueError ( \"Stock cannot be negative\" ) q = demand ( p ) stock -= q profit = p * q print ( p , q , profit , stock ) 10 0 0 10 10 0 0 10 10 0 0 10 5 1 5 9 10 0 0 9 5 1 5 8 5 0 0 8 10 1 10 7 10 0 0 7 5 0 0 7 10 1 10 6 10 0 0 6 10 0 0 6 5 1 5 5 10 0 0 5 5 1 5 4 5 1 5 3 10 0 0 3 10 1 10 2 10 0 0 2 5 1 5 1 5 1 5 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 demand ( np . inf ) 1","title":"Dynamic Programming"},{"location":"notebooks/simulations/nb_dynamic_programming/#dynamic-pricing-as-a-dynamic-programming-problem","text":"","title":"Dynamic pricing as a dynamic programming problem"},{"location":"notebooks/simulations/nb_dynamic_programming/#intro","text":"We present the basics of dynamic programming and frame the dynamic pricing as a dynamic programming problem. In its simplest form, dynamic programming problems consist of two principal features: a discrete-time dynamic process and a cost function that is additive over time. There is a process that happens in stages and an agent is allowed to act in each stage with the objective of minimizing a pre-defined cost function. Every action of the agent must not be considered in isolation. Rather, while deciding what to do in period $k$, the agent should usually weigh in the effects that her current actions might have on subsequent (future) stages. Such a general framework, as one might expect, has applications in very diverse fields such as computer science, operations research and economics. A dynamic system is usually described as follows: \\begin{equation} x_{k+1} = f_k(x_k, u_k, w_k) \\end{equation} where $k \\in {0,1...,N-1}$ is the time index $x_k$ is the state of the system at time $k$ $u_k$ is the control variable through which the agent can influence the system's state $w_k$ is the disturbance, a random variable whose realization also determines the system's state $f_k$ is a function that that describes the mechanism through which the system state is updated. To fully characterize the decision problem, a cost function that will steer the agent's decision-making. The total cost is \\begin{equation} g_N(x_N) + \\sum\\limits_{k=0}^{N-1} g_k(x_k, u_k, w_k) \\end{equation} where $g_N(x_N)$ is the final cost occured right at the very end of the process.","title":"Intro"},{"location":"notebooks/simulations/nb_dynamic_programming/#pricing-as-a-dynamic-programming-problem","text":"The state $x_k$ is the inventory. The control $u_k$ is the price. $u_k \\in {5, 10}$ The random noise $w_k$ is the demand. \\begin{equation} x_{k+1} = f(x_k, u_k, w_k) = \\begin{cases} x_k - 1 & \\text{if $w_k = 1$ }\\ x_k & \\text{if $w_k = 0$ }\\ \\end{cases} \\end{equation}","title":"Pricing as a dynamic programming problem"},{"location":"notebooks/simulations/nb_dynamic_programming/#cost-function","text":"$g_k = $ import random import numpy as np stock = 10 # Initial stock def pick_strategy (): if random . random () > 0.5 : return 5 return 10 def demand ( p ): mapping = { 5 : 0.7 , 10 : 0.3 , np . inf : 0 } try : prob = mapping [ p ] except KeyError : raise ValueError ( f \"Price { p } not allowed\" ) if random . random () > prob : return 0 return 1 for _ in range ( 40 ): if stock > 0 : p = pick_strategy () elif stock == 0 : p = np . inf else : raise ValueError ( \"Stock cannot be negative\" ) q = demand ( p ) stock -= q profit = p * q print ( p , q , profit , stock ) 10 0 0 10 10 0 0 10 10 0 0 10 5 1 5 9 10 0 0 9 5 1 5 8 5 0 0 8 10 1 10 7 10 0 0 7 5 0 0 7 10 1 10 6 10 0 0 6 10 0 0 6 5 1 5 5 10 0 0 5 5 1 5 4 5 1 5 3 10 0 0 3 10 1 10 2 10 0 0 2 5 1 5 1 5 1 5 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 inf 0 nan 0 demand ( np . inf ) 1","title":"Cost function"}]}